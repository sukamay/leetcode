---
title: leetcode_hard_639

date: 2019/08/11 00:24:37
categories:
-leetcode
---

# leetcode_hard_639



>一条包含字母 A-Z 的消息通过以下的方式进行了编码：
>
>'A' -> 1
>'B' -> 2
>...
>'Z' -> 26
>除了上述的条件以外，现在加密字符串可以包含字符 '*'了，字符'*'可以被当做1到9当中的任意一个数字。
>
>给定一条包含数字和字符'*'的加密信息，请确定解码方法的总数。
>
>同时，由于结果值可能会相当的大，所以你应当对109 + 7取模。（翻译者标注：此处取模主要是为了防止溢出）
>
>示例 1 :
>
>输入: "*"
>输出: 9
>解释: 加密的信息可以被解密为: "A", "B", "C", "D", "E", "F", "G", "H", "I".
>示例 2 :
>
>输入: "1*"
>输出: 9 + 9 = 18（翻译者标注：这里1*可以分解为1,* 或者当做1*来处理，所以结果是9+9=18）
>说明 :
>
>输入的字符串长度范围是 [1, 105]。
>输入的字符串只会包含字符 '*' 和 数字'0' - '9'。

## Method 1:

动态规划，需要分比较多情况，但是理清楚就好了
given string : $x_1x_2 \dots x_n$ , $f(n)$ 为长度为 $n$ 的解码方式🌲
$$
f(n) = f(n-1) * g(x_n) + f(n-2) * g(x_{n-1}x_n)
$$

$$
g(x_n) = \begin{matrix} 9,x_n = '*' \\ 0, x_n = '0' \\ 1, else\end{matrix}
$$
括号里表示ab两个字符的取值，我懒得写了QAQ
$$
g(ab) = \begin{matrix}2 & (*,0-6 ) \\ 1 & (*,7-9)  \\ 9 & (1,*) \\ 6 &(2,*) \\ 0 & (3-9,*) \\ 15 & (*,*) \\ 0 & (0,-) \\ 1 & (1,0-9) \\ 1 & (2,0-6) \\ 0 && else\end{matrix}
$$



```C++
class Solution {
public:
    int numDecodings(string s) {
        const int MOD = 1000000007;
        int len = s.length();
        vector<int> dp(len+1,1);
        if(s[0] == '0'){
            return 0;
        }else if(s[0] == '*'){
            dp[1] = 9;
        }
        for(int i = 1;i < len;i++){
            long g1,g2;
            if(s[i] == '*'){
                g1 = 9;
            }else if(s[i] == '0'){
                g1 = 0;
            }else{
                g1 = 1;
            }
            if(s[i-1] == '*'){
                if(s[i] == '*'){
                    g2 = 15;
                }else if(s[i] < '7'){
                    g2 = 2;
                }else{
                    g2 = 1;
                }
            }else if(s[i] == '*'){
                if(s[i-1] == '1'){
                    g2 = 9;
                }else if(s[i-1] == '2'){
                    g2 = 6;
                }else{
                    g2 = 0;
                }
            }else if((s[i-1] == '0') || (s[i-1] > '2') || (s[i-1] == '2' && s[i] > '6')){
                g2 = 0;
            }else{
                g2 = 1;
            }
            dp[i+1] = (g1 * dp[i] + g2 * dp[i-1])% MOD;
            // cout << i+1 << " : " << dp[i+1] << endl;
        }
        return dp[len];
    }
};
```

>执行结果：
>
>通过
>
>显示详情 
>
>执行用时 :68 ms, 在所有 C++ 提交中击败了57.81%的用户
>
>内存消耗 :19 MB, 在所有 C++ 提交中击败了46.43%的用户

leetcode减少时间一个颇为有效的方法：

开头加上

```C++
static const auto _ = []()
{
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    return nullptr;
}();
```

特别是输出比较多的题目效果非常明显，这段代码主要是允许输入输出异步，详情可看ios部分的相关参数意义

加上之后

>执行结果：
>
>通过
>
>显示详情 
>
>执行用时 :28 ms, 在所有 C++ 提交中击败了100.00%的用户
>
>内存消耗 :18.9 MB, 在所有 C++ 提交中击败了46.43%的用户